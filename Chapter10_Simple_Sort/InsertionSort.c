
#include <stdio.h>

void InsertSort(int arr[], int n) {
	int i, j;
	int insData;

	for (i = 1; i < n; i++) {				// 첫 번째 데이터는 이미 정렬 되었다고 보기 때문에 i = 1부터 반복
		insData = arr[i];					// 정렬대상을 insData에 저장

		for (j = i - 1; j >= 0; j--) {		// 정렬된 부분(인덱스 0 ~ i - 1) 탐색
			if (arr[j] > insData)			// insData보다 우선순위가 높은 데이터를 만날 때까지 반복
				arr[j + 1] = arr[j];
			else
				break;
		}

		arr[j + 1] = insData;				// 찾은 위치에 정렬대상 삽입
	}
}

/*

	[삽입 정렬(Insertion Sort)]

	삽입 정렬은 정렬대상을 두 부분으로 나눠서, 정렬 안 된 부분에 있는 데이터를 정렬된 부분의
	특정 위치에 '삽입'해 가면서 정렬을 진행하는 알고리즘이다.


			1	2	4	7	3	5
			-------------	-----
				정렬됨	 정렬되지 않음


				insData	  = 3
							^
			1	2	4	7  [ ]	5		3의 자리를 찾자!

			1	2	4  [ ]	7	5		3과 7 비교 후, 7을 한 칸 뒤로 이동

			1	2  [ ]	4	7	5		3과 4 비교 후, 4를 한 칸 뒤로 이동

			1	2	3	4	7	5		3과 2 비교 후, 3 삽입!
			-----------------  ---
				  정렬됨	  정렬되지 않음

	------------------------------------------------------------------------------------

	<성능평가>

		
			for (i = 1; i < n; i++) {
				...

				for (j = i - 1; j >= 0; j--) {
					if (arr[j] > insData)			// 데이터간 비교연산
						arr[j + 1] = arr[j];		// 데이터 이동의 핵심연산!
					else
						break;
				}
				...
			}


	바깥쪽 for문의 반복횟수와 안쪽 for문의 반복횟수를 곱한 수만큼 비교연산도, 이동연산도 진행이 되므로,
	이를 근거로 비교연산과 이동연산에 대한 빅-오가 다음과 같음을 쉽게 추측할 수 있다.
	(앞서 공부한 3개의 정렬방법은 큰 틀에서 볼 때 비슷한 형태를 띄기 때문)

			O(n^2)

	------------------------------------------------------------------------------------

	결론: 단순한 정렬 알고리즘들은 정렬대상의 수가 적은 경우 효율적으로 사용할 수 있어서 나름의 의미를 지니지만
		  정렬대상의 수가 적지 않은 경우에는 보다 만족스러운 결과를 보장하는 알고리즘이 필요하다.

*/

