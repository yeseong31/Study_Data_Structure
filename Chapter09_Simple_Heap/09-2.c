
/*

	 09-2 [힙의 구현과 우선순위 큐의 완성]

	 여기서 중요한 것은
	 힙은 단지 우선순위 큐의 구현을 위해 쓰이는 것이지, 힙과 우선순위 큐가 동일한 것은 아니라는 것이다.

	----------------------------------------------------------------------------------------------

	O 힙에서의 데이터 저장과정

		가정:	자식 노드 데이터의 우선순위 <= 부모 노드 데이터의 우선순위

		"새로운 데이터는 우선순위가 제일 낮다는 가정하에서 '마지막 위치'에 저장한다.
		 그리고는 부모 노드와 우선순위를 비교해서 위치가 바뀌어야 한다면 바꿔준다ㅏ.
		 바뀐 다음에도 계속해서 부모 노드와 비교한다. 제대로 된 위치를 찾을 때까지"

	----------------------------------------------------------------------------------------------

	O 힙에서의 데이터 삭제과정

		우선순위 큐의 삭제는 '가장 높은 우선순위의 데이터 삭제'를 의미하므로,
		루트 노드를 삭제한 다음 마지막 노드를 루트 노드의 자리로 옮긴 다음에, 자식 노드와의 비교를 통해 제자리를 찾아가게 한다.
		이때 자식 노드가 두 개 있는 경우, 둘 중 우선순위가 더 높은 노드와만 비교한다.

	----------------------------------------------------------------------------------------------

	O 삽입과 삭제의 과정에서 보인 성능의 평가

			- 배열 기반 데이터 저장의 시간 복잡도				O(n)
			- 배열 기반 데이터 삭제의 시간 복잡도				O(1)

			- 연결 리스트 기반 데이터 저장의 시간 복잡도		O(n)
			- 연결 리스트 기반 데이터 삭제의 시간 복잡도		O(1)

		"힙을 기반으로 하면 트리의 높이에 해당아는 수만큼만 비교연산을 진행하면 된다."

			- 힙 기반 데이터 저장의 시간 복잡도				O(log2 n)
			- 힙 기반 데이터 삭제의 시간 복잡도				O(log2 n)

		힙은 완전 이진 트리이므로, 힙에 저장할 수 있는 데이터의 수는 트리의 높이가 하나 늘 때마다 두 배씩 증가한다.
		때문에 데이터의 수가 두 배 늘 때마다, 비교연산의 횟수는 1회 증가한다.

		힙의 시간 복잡도가 위와 같다는 사실은
		다음 Chapter를 공부하는 데에도 필요한 내용이므로 이해하고 넘어갈 것.

	----------------------------------------------------------------------------------------------

	O 힙의 구현에 어울리는 것은 연결 리스트? 아니면 배열?

		우선순위 큐의 구현에 어울리는 것은 힙으로 결론이 났다. 이젠 힙의 구현방법에 대해 고민해야 한다.
		힙은 트리이다. 앞서 트리를 구현하는 방법에는 '배열' 또는 '연결 리스트'를 이용하면 됐었다.

		이때 연결 리스트를 기반으로 힙을 구현하면, 새로운 노드를 힙의 '마지막 위치'에 추가하는 것이 쉽지 않으므로
		힙과 같이, 새로운 노드를 추가한 이후에도 완전 이진 트리를 유지해야 하는 경우에는 '배열을 기반으로 트리를 구현'해야 한다.

	----------------------------------------------------------------------------------------------

	O 배열을 기반으로 힙을 구현하는데 필요한 지식들

						
						A			
					   / \			배열	인덱스	0	1	2	3	4	5	6	7
					  B   C			=>				A	B	C	D	E
					 / \
					D   E

			
			<'배열 기반'에서 인덱스 값 구하기>

				- 왼쪽 자식 노드의 인덱스 값				부모 노드의 인덱스 값 * 2
				- 오른쪽 자식 노드의 인덱스 값				부모 노드의 인덱스 값 * 2 + 1
				- 부모 노드의 인덱스 값					자식 노드의 인덱스 값 / 2

*/


