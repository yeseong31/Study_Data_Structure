
/*

	11-1 [탐색의 이해와 보간 탐색]

=== O 보간 탐색(Interpolation Search)  ==========================================================================================
		
		앞서 우리는 Chapter 01과 02에서 다음 두 가지 탐색 알고리즘을 접하였다.

			- 정렬되지 않은 대상을 기반으로 하는 탐색			순차 탐색
			- 정렬된 대상을 기반으로 하는 탐색					이진 탐색		-> 이를 보완한 것이 '보간 탐색'!

		이진 탐색은 찾는 대상의 위치에 따라서 탐색의 효울에 차이가 발생한다.
		그러나 보간 탐색은 이러한 이진 탐색의 비효울성을 개선시킨 알고리즘이다. 개선의 원리는 다음과 같다.

			"이진 탐색처럼 그냥 중앙에서 탐색을 시작하지 말고, 탐색대상이 앞쪽에 위치해 있으면 앞쪽에서 탐색을 시작하자!"

				------------------------------------------------------------------------------------------------------
				보간 탐색 탐색 위치				이진 탐색 탐색 위치				<- 정수 12를 찾을 때의 첫 번째 탐색 위치
						V								V
				10	11	12	13	14	15	16	17	18	19	20	21	22	23	24	25	26	27	28	29	30
				------------------------------------------------------------------------------------------------------

		이진 탐색은 값에 상관없이 탐색위치를 결정하지만, 보간 탐색은 그 값이 상대적으로 앞에 위치한다고 판단하면 앞쪽에서 탐색을 진행한다.
		따라서 '데이터'와 데이터가 저장된 위치의 '인덱스 값'이 직선의 형태로 비례하면(선형의 형태로 비례), 보간 탐색의 경우 단번에 데이터를 찾기도 한다.
		단번에 찾지 못하더라도 탐색의 위치가, 찾는 데이터와 가깝기 때문에 탐색대상을 줄이는 속도가 이진 탐색보다 뛰어나다.


===	O 보간 탐색의 비례식 구성  ================================================================================================

			------------------------------------------------------------------------------------------------------

			<..........................( A = arr[high]-arr[low] )...........................>		
			<........( Q = arr[s]-arr[low] )........>
			
			10	11	12	13	14	15	16	17	18	19	20	21	22	23	24	25	26	27	28	29	30
			^										^										^
			low										s									   high

				low, high   : 탐색대상의 시작과 끝에 해당하는 인덱스 값
				s		    : 찾고자 하는 데이터의 인덱스 값
				arr[s] = x	: 찾는 데이터의 값

			------------------------------------------------------------------------------------------------------

			A : Q = (high-low) : (s-low)

			s = (Q(high-low) + low) / A

					  x - arr[low]
			s = ----------------------- x (high - low) + low		이로써 찾는 값을 x에 삽입하여 탐색위치 s를 구하는 식이 완성됨
				  arr[high] - arr[low]


=== O 탐색 키(Search Key)와 탐색 데이터(Search Data)  ======================================================================

			typedef int Key;			// 탐색 키에 대한 typedef 선언			
			typedef double Data;		// 탐색 데이터에 대한 typedef 선언

			typedef struct item {		
				Key searchKey;			// 탐색 키(search key)
				Data searchData;		// 참색 데이터(search data)
			} Item;

		실제 프로그램 개발에 있어서 탐색의 대상은 '데이터'가 아니라 '키(key)'이다.
		일반적인 상황에서는 위의 구조체 정의에서 보이듯 탐색 키와 탐색 데이터를 묶는 형태의 구조체를 정의하게 되고,
		앞서 보인 정렬일 지금 이야기하는 탐색이나 그 탐색의 대상을 탐색 키에 맞추게 된다.
	

=== O 보간 탐색의 구현 ===================================================================================================

		이론적으로 보간 탐색과 이진 탐색의 유일한 차이점은 탐색의 대상을 선정하는 방법에 있다.
		
			- 이진 탐색			mid = (first + last) / 2;
			- 보간 탐색			mid = ((double)(target - arr[first]) / (arr[last] - arr[first]) * (last - first)) + first;

		하지만 위처럼 mid를 수정하게 되면 ISearch 함수가 제대로 동작하지 않음을 확인할 수 있다.
		문제는 ISearch 함수의 탈출조건에서 알 수 있다.

			if (first > last)
				return -1;		// -1의 반환은 탐색의 실패를 의미

		결론부터 말하자면 ISearch 함수의 탈출조건은 다음과 같이 바뀌어야 한다.

			if (arr[first] > target || arr[last] < target)
				return -1;

		탐색대상이 존재하지 않는 경우, ISearch 함수가 재귀적으로 호출됨에 따라 target에 저장된 값은
		first와 last가 가리키는 값의 범위를 넘어서게 된다. 
		앞서 우리는 이진 탐색을 구현할 때 first와 last가 뒤바뀌도록 구현했었다. (절대 이진 탐색 자체적으로 뒤바뀌는 게 아니다!)
		따라서 이러한 특성을 기반으로 위와 같이 탈출조건을 구성해야 한다.


=== O 탈출조건을 만족하지 않는 이유 =======================================================================================

		다음과 같이 ISearch 함수가 호출되었다고 가정해보자.

			int main(void) {
				int arr[] = { 1, 3, 5, 7, 9 };
				...
				ISearch(arr, 1, 4, 2);				// 배열 arr의 인덱스 1~4 범위 내에서 숫자 2를 탐색 (탐색대상이 존재하지 않음)
				...
			}

		이를 대상으로 탐색위치를 계산하는 mid에 값들을 대입하다 보면 다음과 같아짐을 알 수 있다.

			mid = 0

		이는 다음과 같은 문장과 결합되면서 문제가 된다.

				if (arr[mid] == target)									
					return mid;
				else if (target < arr[mid])
					return BSearch(arr, first, mid - 1, target);
				else
					return BSearch(arr, mid + 1, last, target);			// 이 문장이 실행된다.

		조건에 의해 마지막 else 구문의 ISearch 함수 호출문이 실행된다.
		그리고 그 결과 다시 한 번 다음과 같이 ISearch 함수에 인자가 전달된다.

			ISearch(arr, 1, 4, 2);			// 이전 호출문과 인자의 전달이 동일하다!

		이렇듯 함수의 전달인자는 ISearch 함수의 탈출조건을 만족하지 못하면서, 무한루프를 형성하게 된다.
		그래서 위의 예제에서는 '탐색대상이 존재하지 않을 경우, 탐색대상의 값은 탐색범위의 값을 넘어선다'는 사실을 근거로
		탈출조건을 다음과 같이 수정해야 한다.

			if (arr[first] > target || arr[last] < target)				// target(2)이 first(3)와 last(9) 사이에 존재하지 않으므로		
				return -1;												// 반복문을 빠져나가야 함!
			

*/


