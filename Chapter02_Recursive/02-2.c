
/*

	02-2 [재귀의 활용]

	<피보나치 수열>

		fib(n) =	0							n = 1
					1							n = 2
					fib(n-1) + fib(n-2)			otherwise


							||
							VV

		int Fibo(int n) {							// 피보나치 수열의 n번째 값 반환
			if (n == 1)							
				return 0;
			else if (n == 2)
				return 1;
			else
				return Fibo(n - 1) + Fibo(n - 2);
		}


		중요한 것은 수학적 재귀의 표현이 그대로 코드로 옮겨졌음을 인식하는 것이다.

		피보나치 수열을 구하는데 있어서 가장 기본이 되는 리소스(자료)는 '0'과 '1'이다.
		처음에 '0'과 '1'이 주어지지 않는다면 문제를 해결할 수 없기 때문이다.
		추가적으로 필요한 것은 덧셈을 이용해 프로그래머가 직접 구하면 되는 일이다.
		... 이는 앞으로 재귀 함수를 이용하는 문제들의 해결 방법에도 활용된다.


	<이진 탐색 알고리즘의 재귀적 구현>
		이 알고리즘을 수식적으로 표현하기는 부적절하지만 알고리즘의 논리 자체는 재귀적이기 때문에
		이진 탐색 알고리즘을 재귀함수 기반으로 재구현할 수 있다.



	<하노이 타워>
		하노이 타워 문제는 '하나의 막대에 쌓여 있는 원반을 다른 하나의 원반에 그대로 옮기는 방법'에 관한 것이다.

		제약사항
			1. 원반은 한 번에 하나씩만 옮길 수 있다.
			2. 옮기는 과정에서 작은 원반의 위에 큰 원반이 올려져서는 안 된다.

		
			4개의 원반을 대상으로 생각해 볼 때					A = From	B = by		C = to
				목적:	4개의 원반을 A에서 C로 이동
				1.		작은 원반 3개를 A에서 B로 이동
				2.		큰 원반 1개를 A에서 C로 이동
				3.		작은 원반 3개를 B에서 C로 이동

							||
							VV

			void Hanoi(int n, char from, char by, char to) {
				if (n == 1)													// 이동해야 할 원반의 수가 1개이면 그냥 옮기기만 하면 된다! 이것이 탈출의 조건!
					printf("원반 %d를 %c에서 %c로 이동\n", n, from, to);
				else {
					Hanoi(n - 1, from, to, by);
					printf("원반 %d를 %c에서 %c로 이동\n", n, from, to);
					Hanoi(n - 1, by, from, to);
				}
			}

*/






