
/*

	10-2 [복잡하지만 효율적인 정렬 알고리즘]

===============================================================================================================
===============================================================================================================

[힙 정렬(Heap Sort)]

	힙 정렬은 힙을 이용한 정렬방식으로
	앞서 공부했던 '우선순위 큐와 힙'에 대해 알면 별도로 더 공부할 것이 없는 알고리즘이다.
	'힙의 루트 노드에 저장된 값이 정렬순서상 가장 앞선다'는 특성을 활용하여 정렬하는 알고리즘이다.

	위 예제의 실행을 위해서는
	UsefulHeap.h와 UsefulHeap.c 두 개의 파일과 함께 컴파일을 해야 한다.
	컴파일에 앞서 헤더파일 UsefulHeap.h의 typedef 선언을 다음과 같이 바꿔야 한다.

			typedef int HData;

	---------------------------------------------------------------------------------------------------------

	<성능평가>

	앞서 Chapter 09에서는 비교연산의 횟수를 근거로 하여 힙의 데이터 저장 및 삭제의 시간 복잡도를 다음과 같이 계산했다.

		- 힙의 데이터 저장 시간 복잡도			O(log2 n)
		- 힙의 데이터 삭제 시간 복잡도			O(log2 n)

	따라서 삽입과 삭제를 하나의 연산으로 묶는다면, 이 연산에 대한 시간 복잡도는 O(2 log2 n)이 되므로
	숫자 2를 무시하게 된다면 다음과 같은 결론이 나온다.

		- 연산에 대한 시간 복잡도				O(log2 n)

	또한 정렬대상의 수가 n개라면, 총 n개의 데이터를 삽입 및 삭제해야 하므로 자음의 결론이 나온다.

		- 정렬과정에 대한 시간 복잡도			O(n log2 n)

===============================================================================================================
===============================================================================================================

[병합 정렬(Merge Sort)]

	병합 정렬은 '분할 정복(Divide And Conquer)'이라는 알고리즘 디자인 기법에 근거하여 만들어진 정렬 방법이다.

		분할(Divide) > 정복(Conquer) > 결합(Combine)			-> 하나의 복잡한 문제를 쪼개어서 풀어나간다.

	"병합 정렬은 데이터가 1개만 남을 때까지 분할을 해나간다.
	 데이터가 2개만 남아도 정렬을 할 필요가 있지만, 데이터가 1개만 남으면 그조차도 불필요해지기 때문이다."

			   82371546					|				
										|				분할의 과정이 재귀적이다!
			 8237	 1546				|				
										|				별도의 정렬이 진행되지 않아도 될 수준까지 분할한다.
		82	  37	  15	46			|				(해결하기 쉬운 단계까지 분할한다는 것에 주목!)
										|
	 8	2	3	7	1	5	4	6		V  분할의 과정
										|				
		28	  37	  15	46			|				그냥 묶는 것이 아니라 정렬순서를 고려해서 묶는다.
										|
			 2378	 1456				|	
										|
			   12345678					V  병합의 과정

	---------------------------------------------------------------------------------------------------------

	<성능평가>

	합 정렬의 성능은 MergeSort 함수가 아닌, MergeTwoArea 함수를 기준으로 계산해야 한다.
	비교연산과 이동연산이 실제 정렬을 진행하는 MergeTwoArea 함수를 중심으로 진행되기 때문이다.

	"정렬의 대상인 데이터의 수가 n개일 때, 각 병합의 단계마다 최대 n번의 비교연산이 진행된다."
	따라서 병합 정렬의 비교연산에 대한 빅-오는 다음과 같다.

		O(n log2 n)					// 최대 비교연산의 횟수: 데이터 개수(n) x 병합 단계 수(log2 n)

	데이터의 이동이 발생하는 이유는 다음과 같다.

		- 임시 배열에 데이터를 병합하는 과정에서 한 번!
		- 임시 배열에 저장된 데이터 전부를 원위치로 옮기는 과정에서 한 번!

	따라서 병합 정렬의 이동현산 횟수는 최악, 평균, 최선 상관없이 (2n log2 n)인데
	빅-오에서 숫자 2는 무시할 수 있으므로, 병합 정렬의 이동연산에 대한 빅-오는 다음과 같다.

		O(n log2 n)					// 데이터의 수가 늘어나도 빅-오는 변함없음

===============================================================================================================
===============================================================================================================

[퀵 정렬(Quick Sort)]
	
	퀵 정렬도 앞서 소개한 병합 정렬과 마찬가지로 '분할 정복'에 근거하여 만들어진 정렬 방법이다.
	그리고 퀵 정렬은 그 이름이 의미하듯이 평균적으로 매우 빠른 정렬의 속도를 보이는 알고리즘이다.

		<퀵 정렬의 기본>
		----------------------------------------------------------------------------------------------------------------------------------------------

		   left						      right			- left:		정렬대상의 가장 왼쪽 지점을 가리키는 이름
			v								v			- right:	정렬대상의 가장 오른쪽 지점을 가리키는 이름
			5	1	3	7	9	2	4	6	8			- pivot:	중심점 또는 중심축. 정렬을 진행하는데 필요한 일종의 '기준' (가장 왼쪽의 데이터라고 결정)
			^	^							^			- low:		pivot을 제외한 가장 왼쪽에 위치한 지점을 가리키는 이름
	 	 pivot low						   high			- high:		pivot을 제외한 가장 오른쪽에 위치한 지점을 가리키는 이름

		----------------------------------------------------------------------------------------------------------------------------------------------

			5	1	3	7	9	2	4	6	8			low의 오른쪽 방향 이동:	pivot보다 정렬의 우선순위가 낮은 데이터를 만날 때까지
			^	 >>>>>	^			^  <<<<<			high의 왼쪽 방향 이동:	pivot보다 정렬의 우선순위가 높은 데이터를 만날 때까지
		 pivot  	   low		   high					이 상황에서는 low와 high는 각각 7과 4를 가리키게 된다.

		----------------------------------------------------------------------------------------------------------------------------------------------

			5	1	3  '4'	9	2  '7'	6	8			low와 high의 이동이 완료되었으면 이 둘이 가리키는 데이터를 서로 '교환'한다.
			^			^			^					교환 후에도 low는 pivot보다 큰 값을 찾을 때까지 오른쪽으로,
		 pivot  	   low		   high					high는 pivot보다 작은 값을 찾을 때까지 왼쪽으로 이동해 나간다.

		----------------------------------------------------------------------------------------------------------------------------------------------

			5	1	3	4	9	2	7	6	8			=>				5	1	3	4  '2' '9'	7	6	8		
			^			>>	^	^  <<				 이동 완료			^				^	^  
		 pivot  		   low high					데이터 교환			pivot  		   low high	
		 		
		----------------------------------------------------------------------------------------------------------------------------------------------

			5	1	3	4	2	9	7	6	8			그러면 결국에는 다음과 같이 low와 high가 가리키는 위치가 교차되는 상황이 발생한다.
			^				^	^  						이때는 low와 high가 가리키는 값을 교환하지 않는다.
		 pivot  		'high''low'						이 상황은 low와 high의 이동 및 교환의 과정이 완료되었음을 의미하기 때문이다.
		
		----------------------------------------------------------------------------------------------------------------------------------------------

		   '2'	1	3	4  '5'	9	7	6	8			따라서 이번에는 pivot과 high가 가리키는 데이터를 서로 '교환'하여 다음 그림의 상태가 되게 한다.
			-------------	^	-------------			이로써 pivot이었던 숫자 5는 홀로 정렬이 완성되었다. (여기까지가 1회전)
		   		 (1)			 	 (2)				(1):	pivot이었던 데이터 '5'보다 우선순위 높음
														(2):	pivot이었던 데이터 '5'보다 우선순위 낮음

		----------------------------------------------------------------------------------------------------------------------------------------------

		   left		  right	|  left		  right			제자리를 찾은 5를 기준으로 왼쪽 영역과 오른쪽 영역을 대상으로 일련의 과정을 반복하게 된다. (재귀)
			v			v	|	v			v			
			2	1	3	4  '5'	9	7	6	8			이 과정은 left와 right가 각각 정렬대상의 시작과 끝을 의미하므로 'left > right',
			^	^			|	^	^		^			즉 left와 right가 교차되는 상황이 되면 더 이상 정렬할 대상이 없을 때까지 반복하게 된다.
		 pivot low			| pivot left   high			

	---------------------------------------------------------------------------------------------------------

	<성능평가>

	분할의 과정에서 둘로 나뉘는 횟수를 k라 할 때, 데이터의 수 n과의 관계는 'k = log2 n'이므로
	퀵 정렬에서 비교연산의 빅-오는 다음과 같다.

		O(n log2 n)

	물론 이것은 최선의 경우에 대한 빅-오이다. 하지만 퀵 정렬의 경우에는 약간의 예외를 둔다.
	이유는 '중간에 가까운 pivot을 선택하는 방법'을 적용함으로써,
	늘 최선의 경우를 보이는 것은 아니지만 최선의 경우에 가까운 성능을 평균적으로 보이기 때문이다.

	최악의 경우, 즉 pivot이 가장 작은 값으로 결정되는 상황에서는, 둘로 나뉘는 횟수 k와 데이터의 수 n과의 관계가 'k = n'이므로
	최악의 경우의 비교연산 횟수에 대한 빅-오는 다음과 같다.

		O(n^2)		(이를 기준으로 퀵 정렬을 평가하지는 않음)

	정리하면, 퀵 정렬은 시간 복잡도가 O(n log2 n)인 알고리즘이다.
	하지만 데이터의 이동이 데이터의 비교에 비해 연저히 적게 일어나고,
	별도의 메모리 공간을 요구하지 않으므로 동일한 빅-오를 갖는 다른 정렬 알고리즘 중에서
	평균적으로 가장 빠른 정렬속도를 보이는 알고리즘이다.

===============================================================================================================
===============================================================================================================

[기수 정렬(Radix Sort)]

	기수 정렬은 정렬순서상 앞서고 뒤섬의 판단을 위한 비교연산을 하지 않는다.
	또한 정렬 알고리즘의 이론상 성능의 한계는 O(n log2 n)으로 알려져 있는데,
	기수 정렬은 이러한 한계를 넘어설 수 있는 유일한 알고리즘이다.

	하지만 '적용할 수 있는 범위가 제한적'이다. 길이가 같은 데이터들을 대상으로는 정렬이 가능하지만,
	길이가 같지 않은 데이터들을 대상으로는 정렬이 불가능하다. (가능은 하지만 효율적인 면에서 단점이 부각됨)

	"n진수 정수의 정렬을 위해서는 총 n개의 '버킷'이 필요하다!"
	그리고 정렬대상은 값에 해당하는 버킷으로 이동을 하게 된다.

		<LSD 기수 정렬의 과정>
		----------------------------------------------------------------------------------------------------------------------------------------------

			- LSD 기수 정렬: Least Significant Digit
							'덜 중요한 자릿수', 즉 첫 번째 자릿수부터 시작해서 정렬을 진행해 나간다는 의미

					V				버킷 -----------------						V
			1	3	4				0:									2	3	2
			1	2	4		->		1:							->		1	2	2		첫 번째 자릿수를 기준으로 버킷 2와 버킷 4에 정렬대상을 넣고 꺼냄
			2	3	2				2: ( 1 2 2 ) ( 2 3 2 )				1	3	4		
			1	2	2				3:									2	2	4		그 결과 232, 122, 134, 224 순으로 데이터들이 정렬됨
					^				4: ( 2 2 4 ) ( 1 3 4 )						^
									----------------------

		----------------------------------------------------------------------------------------------------------------------------------------------

				V					버킷 -----------------					V
			2	3	2				0:									1	2	2
			1	2	2		->		1:							->		2	2	4		첫 번째 과정과 두 번째 과정의 유일한 차이점은 
			1	3	4				2: ( 2 2 4 ) ( 1 2 2 )				2	3	2		두 번째 자릿수가 정렬의 기준이라는 점이다.
			2	2	4				3: ( 1 3 4 ) ( 2 3 2 )				1	3	4		
				^					4:										^
									----------------------

		----------------------------------------------------------------------------------------------------------------------------------------------

			V						버킷 -----------------				V
			1	2	2				0:									1	2	2
			2	2	4		->		1: ( 1 3 4 ) ( 1 2 2 )		->		1	3	4		이로써 오름차순으로의 정렬이 완료되었다.
			2	3	2				2: ( 2 3 2 ) ( 2 2 4 )				2	2	4		(122, 134, 224, 232)
			1	3	4				3:									2	3	2
			^						4:									^
									----------------------

		----------------------------------------------------------------------------------------------------------------------------------------------

		이 LSD 기수 정렬의 단점은 다음과 같다.

			"작은 자릿수에서 시작해서 가장 큰 자릿수까지 모두 비교를 해야 값의 대소를 판단할 수 있다.
			 비교 중간에 대소를 판단하는 것은 불가능하다."

		가장 영향력이 큰 자릿수를 마지막에 비교하니 마지막까지 결과를 알 수 없는 것이 이 방법의 단점이다.

		<LSD vs. MSD>

			이와 반대로 가장 큰 자릿수에서부터 정렬이 진행되는 MSD 방식이 존재한다.
			MSD 정렬 방식은 점진적으로 정렬이 완성되어 가는 구조를 띄며
			"반드시 끝까지 정렬 과정을 거치지 않아도 되며, 중간에 정렬이 완료될 수도 있다"는 것이 장점이다.
			하지만 이러한 경우 "모든 데이터에 일괄적인 과정을 거칠 수 없"게 되므로
			구현의 난이도가 LSD에 비해 상대적으로 높으며, 중간에 데이터의 점검이 요구되므로 성능의 이점도 반감될 수 있다.
			LSD와 MSD의 빅-오는 같지만 일반적인 상황이라면 굳이 MSD 방식을 고집할 이유가 없다.
			
		<LSD 구현>

		양의 정수라면 그 길이에 상관없이 정렬의 대상에 포함시킬 수 있는 기수 정렬을 구현하고자 한다.
		참고로 버킷은 그 구조가 '큐'에 해당하기 때문에 '연결 리스트 기반의 큐'를 활용하면 된다.

	---------------------------------------------------------------------------------------------------------

	<성능평가>

	기수 정렬은 비교연산이 핵심이 아니다. 오히려 버킷으로의 데이터 삽입과 추출이 핵심이다.
	따라서 이 정렬의 시간 복잡도는 삽입과 추출의 빈도수를 대상으로 결정해야 한다.

	버킷을 대상으로 하는 데이터의 삽입과 추출을 한 쌍의 연산으로 묶으면, 이 한 쌍의 연산이 수행되는 횟수는 다음과 같다.
	
		maxLen x num

	따라서 정렬대상의 수가 n이고, 모든 정렬대상의 길이가 l이라 할 때, 시간 복잡도에 대한 기수 정렬의 빅-오는 다음과 같다.

		O(ln)

	물론 이는 O(n)으로 보아도 된다. 그리고 이로써 기수 정렬은 O(n log2 n)인 퀵 정렬보다 뛰어난 O(n)의 성능을 보임을 알 수 있다.
	물론 적용 가능한 대상이 제한적이라는 단점이 있지만 말이다.

*/


