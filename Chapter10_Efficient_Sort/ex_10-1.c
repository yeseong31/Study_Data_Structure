
/*

	문제 10-1 [median of three]

	앞서 구현한 퀵 정렬의 Partition 함수에 다음과 같이 출력문을 삽입하면 선택된 pivot이 무엇인지,
	그리고 정렬과정에서 몇 개의 pivot이 선택되었는지 확인할 수 있다.

		int Partition(int arr[], int left, int right) {
			int pivot = arr[left];									// pivot의 위치는 가장 왼쪽!
			int low = left + 1;
			int high = right;

			printf("pivot: %d\n", pivot);							// pivot의 확인을 위해서 추가할 문장!

			...
		}

	선택된 pivot의 수는 정렬의 효울을 가늠하는 기준이 된다.
	그럼 위와 같이 pivot의 확인을 위한 문장을 삽입한 다음에 다음 배열을 대상으로 정렬을 진행해보자.

		
		int arr[15] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };

	이는 최악의 상황을 연출한 것이다.
	앞서 가장 왼쪽에 위치한 값을 무조건 pivot으로 결정하도로고 구현했기 때문이다.
	실제 실행결과를 보면 총 14개의 pivot이 선택되었음을 확인할 수 있다.
	따라서 우리는 최악의 상황을 면하기 위해서 pivot의 선택방법을 다음과 같이 바꿔보고자 한다.

		"정렬대상의 가장 왼쪽, 가장 오른쪽, 그리고 중간에 위치한 값을 추출해서 이 중에서 중간에 해당하는 값을 pivot으로 결정한다."

	위의 방식대로 pivot이 결정되도록 예제를 변경해야 한다.
	그래서 위의 배열을 대상으로 정렬을 진행했을 때 선택되는 pivot의 수를 확인해보자.

*/



